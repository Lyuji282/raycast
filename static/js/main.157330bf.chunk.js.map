{"version":3,"sources":["utils/point.js","utils/map.js","utils/radians.js","components/minimap.jsx","utils/ray.js","utils/player.js","components/column.jsx","components/scene.jsx","hooks/useKeyPressing.js","hooks/useImmutableStateReducer.js","hooks/useAnimationFrame.js","components/app.jsx","index.js","hooks/useCastRays.js"],"names":["Point","x","y","this","Map","height","size","grid","toGrid","point","unitsPerGrid","Math","floor","prototype","add","distance","other","hypot","isWall","gridCoordinates","isWithinBounds","twoPi","PI","fromDegrees","degrees","Minimap","wallsRef","React","createRef","playerRef","raysRef","drawWalls","drawPlayer","drawRays","context","current","getContext","_this$props","props","map","cellSize","fillStyle","forEach","row","cell","fillRect","_this$props2","player","position","gridX","gridY","minimapX","minimapY","clearRect","beginPath","arc","fill","_this$props3","rays","strokeStyle","i","length","_rays$i","angle","origin","gridDistance","mapDistance","moveTo","lineTo","cos","sin","stroke","prevProps","react_default","a","createElement","style","styles","container","ref","width","layer","Component","top","left","Ray","radians","newAngle","normalize","up","right","horizontalDistance","intersectionY","intersection","tan","deltaY","deltaX","abs","findWall","castHorizontal","verticalDistance","intersectionX","castVertical","min","cast","Infinity","Player","direction","adjustDelta","proposed","delta","castRays","fov","resolution","_this","angleBetweenRays","startAngle","Array","_","index","turnRight","elapsed","turnLeft","moveForward","moveBackward","moveLeft","moveRight","Column","_ref","color","mapHeight","number","screenHeight","screenWidth","backgroundColor","Color","darken","hex","Scene","containerStyles","useMemo","Object","objectSpread","ceiling","ray","adjustDistance","key","border","bottom","reducer","state","action","type","defineProperty","useKeyPressing","handlers","_ref$andThen","andThen","_useImmutableStateRed","initialState","_useReducer","useReducer","_useReducer2","slicedToArray","dispatch","stateRef","useRef","useEffect","useImmutableStateReducer","_useImmutableStateRed2","callback","frameRef","timestampRef","window","performance","now","requestAnimationFrame","loop","timestamp","cancelAnimationFrame","useAnimationFrame","useCallback","isPressingKey","value","keyNames","keys","handleKeyDown","event","includes","handleKeyUp","document","addEventListener","removeEventListener","display","ReactDOM","render","_useState","useState","_useState2","showMinimap","setShowMinimap","setRays","newRays","w","s","d","ArrowLeft","ArrowRight","useCastRays","htmlFor","id","onChange","checked","href","minimap_Minimap","getElementById"],"mappings":"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","file":"static/js/main.157330bf.chunk.js","sourcesContent":["export default function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\n// Return a new point with the values incremented by the passed-in values.\nPoint.prototype.add = function (x, y) {\n  return new Point(this.x + x, this.y + y);\n};\n\n// Return the distance between this point and another.\nPoint.prototype.distance = function (other) {\n  return Math.hypot(this.x - other.x, this.y - other.y);\n};\n","/* eslint-disable no-extend-native */\n\nimport Point from './point';\n\nexport default function Map(height) {\n  this.height = height;\n  this.size = 10;\n  this.grid = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],\n    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n    [1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 0, 1, 1, 1, 0, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  ];\n}\n\nMap.prototype.isWall = function (point) {\n  const gridCoordinates = toGrid(point, this.height);\n  return this.isWithinBounds(point) && this.grid[gridCoordinates.y][gridCoordinates.x] === 1;\n};\n\nMap.prototype.isWithinBounds = function (point) {\n  const gridCoordinates = toGrid(point, this.height);\n  return gridCoordinates.x >= 0 && gridCoordinates.x < this.size && gridCoordinates.y >= 0 && gridCoordinates.y < this.size;\n};\n\n// Convert unit coordinates to grid coordinates. Each grid coordinate can be broken up into\n// some number of smaller \"unit\" coordinates.\nfunction toGrid(point, unitsPerGrid) {\n  return new Point(Math.floor(point.x / unitsPerGrid), Math.floor(point.y / unitsPerGrid));\n}\n","export const twoPi = 2 * Math.PI;\n\n// Convert degrees to radians.\nexport function fromDegrees(degrees) {\n  return degrees * Math.PI / 180;\n}\n\n// Ensure that radians are between 0 and 2π.\nexport function normalize(radians) {\n  const newAngle = radians % twoPi;\n  return newAngle < 0 ? newAngle + twoPi : newAngle;\n}\n","import React from 'react';\nimport { twoPi } from '../utils/radians';\n\nexport default class Minimap extends React.Component {\n  wallsRef = React.createRef()\n  playerRef = React.createRef()\n  raysRef = React.createRef()\n\n  componentDidMount() {\n    this.drawWalls();\n    this.drawPlayer();\n    this.drawRays();\n  }\n\n  drawWalls() {\n    const context = this.wallsRef.current.getContext('2d');\n    const { map, size } = this.props;\n    const cellSize = size / map.size;\n\n    context.fillStyle = 'blue';\n\n    map.grid.forEach((row, y) => {\n      row.forEach((cell, x) => {\n        if (cell === 1) {\n          context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n        }\n      });\n    });\n  }\n\n  drawPlayer() {\n    const context = this.playerRef.current.getContext('2d');\n    const { map, player, size } = this.props;\n    const { position } = player;\n    const gridX = position.x / map.height;\n    const gridY = position.y / map.height;\n    const cellSize = size / map.size;\n    const minimapX = gridX * cellSize;\n    const minimapY = gridY * cellSize;\n\n    context.clearRect(0, 0, size, size);\n    context.fillStyle = 'green';\n    context.beginPath();\n    context.arc(minimapX, minimapY, 5, 0, twoPi);\n    context.fill();\n  }\n\n  drawRays() {\n    const context = this.raysRef.current.getContext('2d');\n    const { map, rays, size } = this.props;\n    const cellSize = size / map.size;\n\n    context.clearRect(0, 0, size, size);\n    context.beginPath();\n    context.strokeStyle = 'green';\n\n    for (let i = 0; i < rays.length; i += 16) {\n      const { angle, distance, origin } = rays[i];\n      const gridX = origin.x / map.height;\n      const gridY = origin.y / map.height;\n      const gridDistance = distance / map.height;\n      const minimapX = gridX * cellSize;\n      const minimapY = gridY * cellSize;\n      const mapDistance = (size / map.size) * gridDistance;\n\n      context.moveTo(minimapX, minimapY);\n      context.lineTo(minimapX + mapDistance * Math.cos(angle), minimapY + mapDistance * -Math.sin(angle));\n      context.stroke();\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.rays !== this.props.rays) {\n      this.drawPlayer();\n      this.drawRays();\n    }\n  }\n\n  render() {\n    const { size } = this.props;\n    return (\n      <div style={styles.container}>\n        <canvas ref={this.wallsRef} height={size} width={size} style={styles.layer} />\n        <canvas ref={this.playerRef} height={size} width={size} style={styles.layer} />\n        <canvas ref={this.raysRef} height={size} width={size} style={styles.layer} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: 'relative',\n  },\n  layer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n  },\n};\n","import Point from './point';\nimport { normalize, twoPi } from './radians';\n\nexport default function Ray(map, angle, origin) {\n  this.origin = origin;\n  this.angle = normalize(angle);\n  this.distance = cast(map, this.angle, origin);\n}\n\n// Determine the distance travelled before hitting a wall.\nfunction cast(map, angle, origin) {\n  // Determine the direction the ray is travelling.\n  const up = angle > 0 && angle < Math.PI;\n  const right = angle < (twoPi * 0.25) || angle > (twoPi * 0.75);\n\n  // Determine the distance to the first horizontal wall.\n  const horizontalDistance = castHorizontal(map, origin, angle, up, right);\n\n  // Determine the distance to the first vertical wall.\n  const verticalDistance = castVertical(map, origin, angle, up, right);\n\n  // Return the shortest distance between the horizontal and vertical distances.\n  return Math.min(horizontalDistance, verticalDistance);\n}\n\n// Determine the distance travelled before hitting a _horizontal_ wall.\nfunction castHorizontal(map, origin, angle, up, right) {\n  // Calculate the coordinates of the first intersection with a grid boundary.\n  const intersectionY = Math.floor(origin.y / map.height) * map.height + (up ? -0.01 : map.height);\n  const intersectionX = origin.x + (origin.y - intersectionY) / Math.tan(angle);\n  const intersection = new Point(intersectionX, intersectionY);\n\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\n  const deltaY = up ? -map.height : map.height;\n  const deltaX = Math.abs(map.height / Math.tan(angle)) * (right ? 1 : -1);\n\n  // Find the nearest wall and return the distance to it.\n  const wall = findWall(map, intersection, deltaX, deltaY);\n  return wall.distance(origin);\n}\n\n// Determine the distance travelled before hitting a _vertical_ wall.\nfunction castVertical(map, origin, angle, up, right) {\n  // Calculate the coordinates of the first intersection with a grid boundary.\n  const intersectionX = Math.floor(origin.x / map.height) * map.height + (right ? map.height : -0.01);\n  const intersectionY = origin.y + (origin.x - intersectionX) * Math.tan(angle);\n  const intersection = new Point(intersectionX, intersectionY);\n\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\n  const deltaX = right ? map.height : -map.height;\n  const deltaY = Math.abs(map.height * Math.tan(angle)) * (up ? -1 : 1);\n\n  // Find the nearest wall and return the distance to it.\n  const wall = findWall(map, intersection, deltaX, deltaY);\n  return wall.distance(origin);\n}\n\n// Process each step the ray takes until encountering a wall or the bounds of the map.\nfunction findWall(map, position, deltaX, deltaY) {\n  // If the ray is no longer within the bounds of the map, return a point infinitely far away.\n  if (!map.isWithinBounds(position)) {\n    return new Point(Infinity, Infinity);\n  }\n\n  // If the ray has hit a wall, return its position.\n  if (map.isWall(position)) {\n    return position;\n  }\n\n  // No wall has been encountered. Iterate to the next grid boundary and check again.\n  return findWall(map, position.add(deltaX, deltaY), deltaX, deltaY);\n}\n","import Point from './point';\nimport Ray from './ray';\n\nconst stepDistance = 1.4; // per 16ms\nconst turnRotation = 0.025; // per 16ms\n\nexport default function Player(x, y, direction) {\n  this.position = new Point(x, y);\n  this.direction = direction;\n}\n\n// Determine the distance to walls the user can see by casting rays of light from the player's\n// eyes and figuring out where they intersect with a wall. The `resolution` is the number of rays\n// to cast, and `fov` determines how spread apart they will be.\nPlayer.prototype.castRays = function (map, fov, resolution) {\n  // If the field of view is 60 degrees and the resolution is 320, there is 60 / 320 degrees\n  // between each ray.\n  const angleBetweenRays = fov / resolution;\n\n  // The player's direction is the center of the screen, and the left edge of the screen is half\n  // the field of view to the left. In our coordinate system, angles increase as we turn counter-\n  // clockwise, so we add to player's current direction.\n  const startAngle = this.direction + fov / 2;\n\n  // Generate the angle for each ray starting from the left and sweeping to the right screen edge.\n  const rayAngles = new Array(resolution).fill(0).map((_, index) => startAngle - index * angleBetweenRays);\n\n  // Calculate the distance from each ray to the nearest wall.\n  return rayAngles.map(angle => new Ray(map, angle, this.position));\n};\n\nPlayer.prototype.turnRight = function (elapsed) {\n  this.direction -= turnRotation * elapsed / 16;\n};\n\nPlayer.prototype.turnLeft = function (elapsed) {\n  this.direction += turnRotation * elapsed / 16;\n};\n\nPlayer.prototype.moveForward = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(deltaX, 0), deltaX),\n    adjustDelta(map, this.position.add(0, -deltaY), -deltaY),\n  );\n};\n\nPlayer.prototype.moveBackward = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(-deltaX, 0), -deltaX),\n    adjustDelta(map, this.position.add(0, deltaY), deltaY),\n  );\n};\n\n// Step to the left, which is the same as stepping forward but rotated 90 degrees to the left.\nPlayer.prototype.moveLeft = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction + Math.PI / 2);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction + Math.PI / 2);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(deltaX, 0), deltaX),\n    adjustDelta(map, this.position.add(0, -deltaY), -deltaY),\n  );\n};\n\n// Step to the right, which is the same as stepping backward but rotated 90 degrees to the left.\nPlayer.prototype.moveRight = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction + Math.PI / 2);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction + Math.PI / 2);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(-deltaX, 0), -deltaX),\n    adjustDelta(map, this.position.add(0, deltaY), deltaY),\n  );\n};\n\n// Perform collision-detection to determine if a proposed new position for the player is a valid\n// one. If it is, return the proposed delta. Otherwise, return 0.\nfunction adjustDelta(map, proposed, delta) {\n  return map.isWall(proposed) ? 0 : delta;\n}\n","import Color from 'color';\nimport React from 'react';\n\nexport default function Column({\n  color,\n  distance,\n  mapHeight,\n  number,\n  resolution,\n  screenHeight,\n  screenWidth,\n}) {\n  const height = Math.min(mapHeight / distance * 255, screenHeight);\n  const width = screenWidth / resolution;\n  const top = (screenHeight - height) / 2;\n  const adjustedColor = Color(color).darken(distance / 460).hex();\n  const styles = {\n    backgroundColor: adjustedColor,\n    height,\n    left: number * width,\n    width,\n    position: 'absolute',\n    top,\n  };\n\n  return <div style={styles} />;\n}\n","import React, { useMemo } from 'react';\nimport Column from './column';\n\nexport default function Scene({\n  height,\n  mapHeight,\n  player,\n  rays,\n  resolution,\n  width,\n}) {\n  const containerStyles = useMemo(() => ({ ...styles.container, height, width }), [height, width]);\n\n  return (\n    <div style={containerStyles}>\n      <div style={styles.ceiling} />\n      <div style={styles.floor} />\n      {rays.map((ray, index) => (\n        <Column\n          color=\"#0000FF\"\n          distance={adjustDistance(ray, player)}\n          key={index} // eslint-disable-line react/no-array-index-key\n          mapHeight={mapHeight}\n          number={index}\n          resolution={resolution}\n          screenHeight={height}\n          screenWidth={width}\n        />\n      ))}\n    </div>\n  );\n}\n\n// Correct for a fishbowl-effect resulting from mixing polar and cartesian coordinates.\nfunction adjustDistance(ray, player) {\n  return ray.distance * Math.cos(ray.angle - player.direction);\n}\n\nconst styles = {\n  container: {\n    border: '1px solid black',\n    position: 'relative',\n  },\n  ceiling: {\n    backgroundColor: 'SlateGrey',\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: '50%',\n    top: 0,\n  },\n  floor: {\n    backgroundColor: 'Gainsboro',\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: '50%',\n  },\n};\n","import forEach from 'lodash.foreach';\nimport { useCallback, useEffect } from 'react';\nimport useAnimationFrame from './useAnimationFrame';\nimport useImmutableStateReducer from './useImmutableStateReducer';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'down':\n      return { ...state, [action.key]: true };\n    case 'up':\n      return { ...state, [action.key]: false };\n    default:\n      return state;\n  }\n}\n\nexport default function useKeyPressing(handlers, { andThen = () => {} }) {\n  const [stateRef, dispatch] = useImmutableStateReducer(reducer, {});\n\n  useAnimationFrame(\n    useCallback(\n      (elapsed) => {\n        let isPressingKey = false;\n\n        // Execute the handler for all keys that are being pressed.\n        forEach(handlers, (value, key) => {\n          if (stateRef.current[key]) {\n            isPressingKey = true;\n            value(elapsed);\n          }\n        });\n\n        if (isPressingKey) { andThen() }\n      },\n      [stateRef, handlers, andThen],\n    ),\n  );\n\n  useEffect(() => {\n    const keyNames = Object.keys(handlers);\n\n    function handleKeyDown(event) {\n      if (keyNames.includes(event.key)) {\n        dispatch({ type: 'down', key: event.key });\n      }\n    }\n\n    function handleKeyUp(event) {\n      if (keyNames.includes(event.key)) {\n        dispatch({ type: 'up', key: event.key });\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handlers, dispatch]);\n}\n","import { useEffect, useReducer, useRef } from 'react';\n\nexport default function useImmutableStateReducer(reducer, initialState) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const stateRef = useRef(state);\n\n  useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  return [stateRef, dispatch];\n}\n","import { useEffect, useRef } from 'react';\n\nexport default function useAnimationFrame(callback) {\n  const frameRef = useRef();\n  const timestampRef = useRef();\n\n  useEffect(() => {\n    timestampRef.current = window.performance.now();\n  }, []);\n\n  useEffect(() => {\n    function loop(timestamp) {\n      frameRef.current = requestAnimationFrame(loop);\n      callback(timestamp - timestampRef.current);\n      timestampRef.current = timestamp;\n    };\n\n    frameRef.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frameRef.current);\n  }, [callback]);\n};\n","import React, { useState } from 'react';\nimport Map from '../utils/map';\nimport Minimap from './minimap';\nimport Player from '../utils/player';\nimport Scene from './scene';\nimport useCastRays from '../hooks/useCastRays';\nimport { fromDegrees } from '../utils/radians';\n\nconst fov = fromDegrees(60);\nconst map = new Map(64);\nconst player = new Player(160, 160, fromDegrees(0));\nconst resolution = 320;\n\nexport default function App() {\n  const [showMinimap, setShowMinimap] = useState(true);\n  const rays = useCastRays(player, map, fov, resolution);\n\n  return (\n    <div style={styles.container}>\n      <div>\n        <Scene\n          height={400}\n          mapHeight={map.height}\n          player={player}\n          rays={rays}\n          resolution={resolution}\n          width={740}\n        />\n        <div>\n          <span>Move using the w, s, a, d, ←, and → keys</span>\n          <div>\n            <label htmlFor=\"show_minimap\">\n              Show minimap\n              <input id=\"show_minimap\" onChange={() => setShowMinimap(!showMinimap)} type=\"checkbox\" checked={showMinimap} />\n            </label>\n          </div>\n          <a href=\"https://github.com/ahuth/raycast\">Source code</a>\n        </div>\n      </div>\n      {showMinimap && (\n        <Minimap\n          fov={fov}\n          map={map}\n          player={player}\n          rays={rays}\n          resolution={resolution}\n          size={300}\n        />\n      )}\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    display: 'flex',\n  },\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app';\nimport './index.css';\n\nReactDOM.render(React.createElement(App), document.getElementById('root'));\n","import { useCallback, useEffect, useMemo, useState } from 'react';\nimport useKeyPressing from './useKeyPressing';\n\nexport default function useCastRays(player, map, fov, resolution) {\n  const [rays, setRays] = useState([]);\n\n  const castRays = useCallback(() => {\n    const newRays = player.castRays(map, fov, resolution);\n    setRays(newRays);\n  }, [player, map, fov, resolution]);\n\n  useEffect(() => { castRays(); }, [castRays]);\n\n  useKeyPressing(\n    useMemo(\n      () => {\n        return {\n          w: (elapsed) => { player.moveForward(map, elapsed); },\n          s: (elapsed) => { player.moveBackward(map, elapsed); },\n          a: (elapsed) => { player.moveLeft(map, elapsed); },\n          d: (elapsed) => { player.moveRight(map, elapsed); },\n          ArrowLeft: (elapsed) => { player.turnLeft(elapsed); },\n          ArrowRight: (elapsed) => { player.turnRight(elapsed); },\n        };\n      },\n      [player, map],\n    ),\n    { andThen: castRays },\n  );\n\n  return rays;\n}\n"],"sourceRoot":""}