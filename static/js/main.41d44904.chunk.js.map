{"version":3,"sources":["utils/point.js","utils/map.js","utils/radians.js","components/minimap.jsx","utils/ray.js","utils/player.js","components/column.jsx","components/scene.jsx","hooks/useKeyPressing.js","hooks/useImmutableStateReducer.js","hooks/useAnimationFrame.js","components/app.jsx","index.js","hooks/useCastRays.js"],"names":["Point","x","y","this","Map","height","size","grid","toGrid","point","unitsPerGrid","Math","floor","prototype","add","distance","other","hypot","isWall","gridCoordinates","isWithinBounds","twoPi","PI","fromDegrees","degrees","Minimap","wallsRef","React","createRef","playerRef","raysRef","drawWalls","drawPlayer","drawRays","context","current","getContext","props","map","cellSize","fillStyle","forEach","row","cell","fillRect","player","position","gridX","gridY","minimapX","minimapY","clearRect","beginPath","arc","fill","rays","strokeStyle","i","length","angle","origin","gridDistance","mapDistance","moveTo","lineTo","cos","sin","stroke","prevProps","style","styles","container","ref","width","layer","Component","top","left","Ray","radians","newAngle","normalize","up","right","horizontalDistance","intersectionY","intersection","tan","deltaY","deltaX","abs","findWall","castHorizontal","verticalDistance","intersectionX","castVertical","min","cast","Infinity","Player","direction","adjustDelta","proposed","delta","castRays","fov","resolution","angleBetweenRays","startAngle","Array","_","index","turnRight","elapsed","turnLeft","moveForward","moveBackward","moveLeft","moveRight","Column","color","mapHeight","number","screenHeight","screenWidth","backgroundColor","Color","darken","hex","Scene","containerStyles","useMemo","ceiling","ray","adjustDistance","key","border","bottom","reducer","state","action","type","useKeyPressing","handlers","andThen","initialState","useReducer","dispatch","stateRef","useRef","useEffect","useImmutableStateReducer","callback","frameRef","timestampRef","window","performance","now","requestAnimationFrame","loop","timestamp","cancelAnimationFrame","useAnimationFrame","useCallback","isPressingKey","value","keyNames","Object","keys","handleKeyDown","event","includes","handleKeyUp","document","addEventListener","removeEventListener","display","ReactDOM","render","createElement","useState","showMinimap","setShowMinimap","setRays","newRays","w","s","a","d","ArrowLeft","ArrowRight","useCastRays","htmlFor","id","onChange","checked","href","getElementById"],"mappings":"8MAAe,SAASA,EAAMC,EAAGC,GAC/BC,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,ECEI,SAASE,EAAIC,GAC1BF,KAAKE,OAASA,EACdF,KAAKG,KAAO,GACZH,KAAKI,KAAO,CACV,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAgBhC,SAASC,EAAOC,EAAOC,GACrB,OAAO,IAAIV,EAAMW,KAAKC,MAAMH,EAAMR,EAAIS,GAAeC,KAAKC,MAAMH,EAAMP,EAAIQ,ID5B5EV,EAAMa,UAAUC,IAAM,SAAUb,EAAGC,GACjC,OAAO,IAAIF,EAAMG,KAAKF,EAAIA,EAAGE,KAAKD,EAAIA,IAIxCF,EAAMa,UAAUE,SAAW,SAAUC,GACnC,OAAOL,KAAKM,MAAMd,KAAKF,EAAIe,EAAMf,EAAGE,KAAKD,EAAIc,EAAMd,ICSrDE,EAAIS,UAAUK,OAAS,SAAUT,GAC/B,IAAMU,EAAkBX,EAAOC,EAAON,KAAKE,QAC3C,OAAOF,KAAKiB,eAAeX,IAA8D,IAApDN,KAAKI,KAAKY,EAAgBjB,GAAGiB,EAAgBlB,IAGpFG,EAAIS,UAAUO,eAAiB,SAAUX,GACvC,IAAMU,EAAkBX,EAAOC,EAAON,KAAKE,QAC3C,OAAOc,EAAgBlB,GAAK,GAAKkB,EAAgBlB,EAAIE,KAAKG,MAAQa,EAAgBjB,GAAK,GAAKiB,EAAgBjB,EAAIC,KAAKG,M,yCC5B1Ge,EAAQ,EAAIV,KAAKW,GAGvB,SAASC,EAAYC,GAC1B,OAAOA,EAAUb,KAAKW,GAAK,I,ICDRG,E,2MACnBC,SAAWC,IAAMC,Y,EACjBC,UAAYF,IAAMC,Y,EAClBE,QAAUH,IAAMC,Y,mFAGdzB,KAAK4B,YACL5B,KAAK6B,aACL7B,KAAK8B,a,kCAIL,IAAMC,EAAU/B,KAAKuB,SAASS,QAAQC,WAAW,MADvC,EAEYjC,KAAKkC,MAAnBC,EAFE,EAEFA,IACFC,EAHI,EAEGjC,KACWgC,EAAIhC,KAE5B4B,EAAQM,UAAY,OAEpBF,EAAI/B,KAAKkC,SAAQ,SAACC,EAAKxC,GACrBwC,EAAID,SAAQ,SAACE,EAAM1C,GACJ,IAAT0C,GACFT,EAAQU,SAAS3C,EAAIsC,EAAUrC,EAAIqC,EAAUA,EAAUA,W,mCAO7D,IAAML,EAAU/B,KAAK0B,UAAUM,QAAQC,WAAW,MADvC,EAEmBjC,KAAKkC,MAA3BC,EAFG,EAEHA,IAAKO,EAFF,EAEEA,OAAQvC,EAFV,EAEUA,KACbwC,EAAaD,EAAbC,SACFC,EAAQD,EAAS7C,EAAIqC,EAAIjC,OACzB2C,EAAQF,EAAS5C,EAAIoC,EAAIjC,OACzBkC,EAAWjC,EAAOgC,EAAIhC,KACtB2C,EAAWF,EAAQR,EACnBW,EAAWF,EAAQT,EAEzBL,EAAQiB,UAAU,EAAG,EAAG7C,EAAMA,GAC9B4B,EAAQM,UAAY,QACpBN,EAAQkB,YACRlB,EAAQmB,IAAIJ,EAAUC,EAAU,EAAG,EAAG7B,GACtCa,EAAQoB,S,iCAIR,IAAMpB,EAAU/B,KAAK2B,QAAQK,QAAQC,WAAW,MADvC,EAEmBjC,KAAKkC,MAAzBC,EAFC,EAEDA,IAAKiB,EAFJ,EAEIA,KAAMjD,EAFV,EAEUA,KACbiC,EAAWjC,EAAOgC,EAAIhC,KAE5B4B,EAAQiB,UAAU,EAAG,EAAG7C,EAAMA,GAC9B4B,EAAQkB,YACRlB,EAAQsB,YAAc,QAEtB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,GAAK,GAAI,CAAC,IAAD,EACJF,EAAKE,GAAjCE,EADgC,EAChCA,MAAO5C,EADyB,EACzBA,SAAU6C,EADe,EACfA,OACnBb,EAAQa,EAAO3D,EAAIqC,EAAIjC,OACvB2C,EAAQY,EAAO1D,EAAIoC,EAAIjC,OACvBwD,EAAe9C,EAAWuB,EAAIjC,OAC9B4C,EAAWF,EAAQR,EACnBW,EAAWF,EAAQT,EACnBuB,EAAexD,EAAOgC,EAAIhC,KAAQuD,EAExC3B,EAAQ6B,OAAOd,EAAUC,GACzBhB,EAAQ8B,OAAOf,EAAWa,EAAcnD,KAAKsD,IAAIN,GAAQT,EAAWY,GAAenD,KAAKuD,IAAIP,IAC5FzB,EAAQiC,Y,yCAIOC,GACbA,EAAUb,OAASpD,KAAKkC,MAAMkB,OAChCpD,KAAK6B,aACL7B,KAAK8B,c,+BAIC,IACA3B,EAASH,KAAKkC,MAAd/B,KACR,OACE,yBAAK+D,MAAOC,EAAOC,WACjB,4BAAQC,IAAKrE,KAAKuB,SAAUrB,OAAQC,EAAMmE,MAAOnE,EAAM+D,MAAOC,EAAOI,QACrE,4BAAQF,IAAKrE,KAAK0B,UAAWxB,OAAQC,EAAMmE,MAAOnE,EAAM+D,MAAOC,EAAOI,QACtE,4BAAQF,IAAKrE,KAAK2B,QAASzB,OAAQC,EAAMmE,MAAOnE,EAAM+D,MAAOC,EAAOI,a,GAjFvC/C,IAAMgD,WAuFrCL,EAAS,CACbC,UAAW,CACTzB,SAAU,YAEZ4B,MAAO,CACL5B,SAAU,WACV8B,IAAK,EACLC,KAAM,IC9FK,SAASC,EAAIxC,EAAKqB,EAAOC,GACtCzD,KAAKyD,OAASA,EACdzD,KAAKwD,MFGA,SAAmBoB,GACxB,IAAMC,EAAWD,EAAU1D,EAC3B,OAAO2D,EAAW,EAAIA,EAAW3D,EAAQ2D,EEL5BC,CAAUtB,GACvBxD,KAAKY,SAIP,SAAcuB,EAAKqB,EAAOC,GAExB,IAAMsB,EAAKvB,EAAQ,GAAKA,EAAQhD,KAAKW,GAC/B6D,EAAQxB,EAAiB,IAARtC,GAAiBsC,EAAiB,IAARtC,EAG3C+D,EAUR,SAAwB9C,EAAKsB,EAAQD,EAAOuB,EAAIC,GAE9C,IAAME,EAAgB1E,KAAKC,MAAMgD,EAAO1D,EAAIoC,EAAIjC,QAAUiC,EAAIjC,QAAU6E,GAAM,IAAO5C,EAAIjC,QAEnFiF,EAAe,IAAItF,EADH4D,EAAO3D,GAAK2D,EAAO1D,EAAImF,GAAiB1E,KAAK4E,IAAI5B,GACzB0B,GAGxCG,EAASN,GAAM5C,EAAIjC,OAASiC,EAAIjC,OAChCoF,EAAS9E,KAAK+E,IAAIpD,EAAIjC,OAASM,KAAK4E,IAAI5B,KAAWwB,EAAQ,GAAK,GAItE,OADaQ,EAASrD,EAAKgD,EAAcG,EAAQD,GACrCzE,SAAS6C,GAtBMgC,CAAetD,EAAKsB,EAAQD,EAAOuB,EAAIC,GAG5DU,EAuBR,SAAsBvD,EAAKsB,EAAQD,EAAOuB,EAAIC,GAE5C,IAAMW,EAAgBnF,KAAKC,MAAMgD,EAAO3D,EAAIqC,EAAIjC,QAAUiC,EAAIjC,QAAU8E,EAAQ7C,EAAIjC,QAAU,KACxFgF,EAAgBzB,EAAO1D,GAAK0D,EAAO3D,EAAI6F,GAAiBnF,KAAK4E,IAAI5B,GACjE2B,EAAe,IAAItF,EAAM8F,EAAeT,GAGxCI,EAASN,EAAQ7C,EAAIjC,QAAUiC,EAAIjC,OACnCmF,EAAS7E,KAAK+E,IAAIpD,EAAIjC,OAASM,KAAK4E,IAAI5B,KAAWuB,GAAM,EAAI,GAInE,OADaS,EAASrD,EAAKgD,EAAcG,EAAQD,GACrCzE,SAAS6C,GAnCImC,CAAazD,EAAKsB,EAAQD,EAAOuB,EAAIC,GAG9D,OAAOxE,KAAKqF,IAAIZ,EAAoBS,GAhBpBI,CAAK3D,EAAKnC,KAAKwD,MAAOC,GAoDxC,SAAS+B,EAASrD,EAAKQ,EAAU2C,EAAQD,GAEvC,OAAKlD,EAAIlB,eAAe0B,GAKpBR,EAAIpB,OAAO4B,GACNA,EAIF6C,EAASrD,EAAKQ,EAAShC,IAAI2E,EAAQD,GAASC,EAAQD,GATlD,IAAIxF,EAAMkG,IAAUA,KCvDhB,SAASC,EAAOlG,EAAGC,EAAGkG,GACnCjG,KAAK2C,SAAW,IAAI9C,EAAMC,EAAGC,GAC7BC,KAAKiG,UAAYA,EA2EnB,SAASC,EAAY/D,EAAKgE,EAAUC,GAClC,OAAOjE,EAAIpB,OAAOoF,GAAY,EAAIC,EAtEpCJ,EAAOtF,UAAU2F,SAAW,SAAUlE,EAAKmE,EAAKC,GAAa,IAAD,OAGpDC,EAAmBF,EAAMC,EAKzBE,EAAazG,KAAKiG,UAAYK,EAAM,EAM1C,OAHkB,IAAII,MAAMH,GAAYpD,KAAK,GAAGhB,KAAI,SAACwE,EAAGC,GAAJ,OAAcH,EAAaG,EAAQJ,KAGtErE,KAAI,SAAAqB,GAAK,OAAI,IAAImB,EAAIxC,EAAKqB,EAAO,EAAKb,cAGzDqD,EAAOtF,UAAUmG,UAAY,SAAUC,GACrC9G,KAAKiG,WA5Bc,KA4Bca,EAAU,IAG7Cd,EAAOtF,UAAUqG,SAAW,SAAUD,GACpC9G,KAAKiG,WAhCc,KAgCca,EAAU,IAG7Cd,EAAOtF,UAAUsG,YAAc,SAAU7E,EAAK2E,GAC5C,IAAMxB,EAAyBwB,EAAU,GArCtB,IAqC4BtG,KAAKsD,IAAI9D,KAAKiG,WACvDZ,EAAyByB,EAAU,GAtCtB,IAsC4BtG,KAAKuD,IAAI/D,KAAKiG,WAE7DjG,KAAK2C,SAAW3C,KAAK2C,SAAShC,IAC5BuF,EAAY/D,EAAKnC,KAAK2C,SAAShC,IAAI2E,EAAQ,GAAIA,GAC/CY,EAAY/D,EAAKnC,KAAK2C,SAAShC,IAAI,GAAI0E,IAAUA,KAIrDW,EAAOtF,UAAUuG,aAAe,SAAU9E,EAAK2E,GAC7C,IAAMxB,EAAyBwB,EAAU,GA/CtB,IA+C4BtG,KAAKsD,IAAI9D,KAAKiG,WACvDZ,EAAyByB,EAAU,GAhDtB,IAgD4BtG,KAAKuD,IAAI/D,KAAKiG,WAE7DjG,KAAK2C,SAAW3C,KAAK2C,SAAShC,IAC5BuF,EAAY/D,EAAKnC,KAAK2C,SAAShC,KAAK2E,EAAQ,IAAKA,GACjDY,EAAY/D,EAAKnC,KAAK2C,SAAShC,IAAI,EAAG0E,GAASA,KAKnDW,EAAOtF,UAAUwG,SAAW,SAAU/E,EAAK2E,GACzC,IAAMxB,EAAyBwB,EAAU,GA1DtB,IA0D4BtG,KAAKsD,IAAI9D,KAAKiG,UAAYzF,KAAKW,GAAK,GAC7EkE,EAAyByB,EAAU,GA3DtB,IA2D4BtG,KAAKuD,IAAI/D,KAAKiG,UAAYzF,KAAKW,GAAK,GAEnFnB,KAAK2C,SAAW3C,KAAK2C,SAAShC,IAC5BuF,EAAY/D,EAAKnC,KAAK2C,SAAShC,IAAI2E,EAAQ,GAAIA,GAC/CY,EAAY/D,EAAKnC,KAAK2C,SAAShC,IAAI,GAAI0E,IAAUA,KAKrDW,EAAOtF,UAAUyG,UAAY,SAAUhF,EAAK2E,GAC1C,IAAMxB,EAAyBwB,EAAU,GArEtB,IAqE4BtG,KAAKsD,IAAI9D,KAAKiG,UAAYzF,KAAKW,GAAK,GAC7EkE,EAAyByB,EAAU,GAtEtB,IAsE4BtG,KAAKuD,IAAI/D,KAAKiG,UAAYzF,KAAKW,GAAK,GAEnFnB,KAAK2C,SAAW3C,KAAK2C,SAAShC,IAC5BuF,EAAY/D,EAAKnC,KAAK2C,SAAShC,KAAK2E,EAAQ,IAAKA,GACjDY,EAAY/D,EAAKnC,KAAK2C,SAAShC,IAAI,EAAG0E,GAASA,K,2BC1EpC,SAAS+B,EAAT,GAQX,IAPFC,EAOC,EAPDA,MACAzG,EAMC,EANDA,SACA0G,EAKC,EALDA,UACAC,EAIC,EAJDA,OACAhB,EAGC,EAHDA,WACAiB,EAEC,EAFDA,aACAC,EACC,EADDA,YAEMvH,EAASM,KAAKqF,IAAIyB,EAAY1G,EAAW,IAAK4G,GAC9ClD,EAAQmD,EAAclB,EACtB9B,GAAO+C,EAAetH,GAAU,EAEhCiE,EAAS,CACbuD,gBAFoBC,IAAMN,GAAOO,OAAOhH,EAAW,KAAKiH,MAGxD3H,SACAwE,KAAM6C,EAASjD,EACfA,QACA3B,SAAU,WACV8B,OAGF,OAAO,yBAAKP,MAAOC,I,8NCtBN,SAAS2D,EAAT,GAOX,IANF5H,EAMC,EANDA,OACAoH,EAKC,EALDA,UACA5E,EAIC,EAJDA,OACAU,EAGC,EAHDA,KACAmD,EAEC,EAFDA,WACAjC,EACC,EADDA,MAEMyD,EAAkBC,mBAAQ,kB,yWAAA,IAAY7D,EAAOC,UAAnB,CAA8BlE,SAAQoE,YAAU,CAACpE,EAAQoE,IAEzF,OACE,yBAAKJ,MAAO6D,GACV,yBAAK7D,MAAOC,EAAO8D,UACnB,yBAAK/D,MAAOC,EAAO1D,QAClB2C,EAAKjB,KAAI,SAAC+F,EAAKtB,GAAN,OACR,kBAACQ,EAAD,CACEC,MAAM,UACNzG,SAAUuH,EAAeD,EAAKxF,GAC9B0F,IAAKxB,EACLU,UAAWA,EACXC,OAAQX,EACRL,WAAYA,EACZiB,aAActH,EACduH,YAAanD,QAQvB,SAAS6D,EAAeD,EAAKxF,GAC3B,OAAOwF,EAAItH,SAAWJ,KAAKsD,IAAIoE,EAAI1E,MAAQd,EAAOuD,WAGpD,IAAM9B,EAAS,CACbC,UAAW,CACTiE,OAAQ,kBACR1F,SAAU,YAEZsF,QAAS,CACPP,gBAAiB,YACjB/E,SAAU,WACV+B,KAAM,EACNM,MAAO,EACPsD,OAAQ,MACR7D,IAAK,GAEPhE,MAAO,CACLiH,gBAAiB,YACjB/E,SAAU,WACV+B,KAAM,EACNM,MAAO,EACPsD,OAAQ,EACR7D,IAAK,Q,0lBCpDT,SAAS8D,EAAQC,EAAOC,GACtB,OAAQA,EAAOC,MACb,IAAK,OACH,OAAO,KAAKF,EAAZ,eAAoBC,EAAOL,KAAM,IACnC,IAAK,KACH,OAAO,KAAKI,EAAZ,eAAoBC,EAAOL,KAAM,IACnC,QACE,OAAOI,GAIE,SAASG,EAAeC,EAAxB,GAA2D,IAAD,IAAtBC,eAAsB,MAAZ,aAAY,ICd1D,SAAkCN,EAASO,GAAe,IAAD,EAC5CC,qBAAWR,EAASO,GADwB,mBAC/DN,EAD+D,KACxDQ,EADwD,KAEhEC,EAAWC,iBAAOV,GAMxB,OAJAW,qBAAU,WACRF,EAASjH,QAAUwG,IAClB,CAACA,IAEG,CAACS,EAAUD,GDOWI,CAAyBb,EAAS,IADQ,mBAChEU,EADgE,KACtDD,EADsD,MEd1D,SAA2BK,GACxC,IAAMC,EAAWJ,mBACXK,EAAeL,mBAErBC,qBAAU,WACRI,EAAavH,QAAUwH,OAAOC,YAAYC,QACzC,IAEHP,qBAAU,WAQR,OADAG,EAAStH,QAAU2H,uBANnB,SAASC,EAAKC,GACZP,EAAStH,QAAU2H,sBAAsBC,GACzCP,EAASQ,EAAYN,EAAavH,SAClCuH,EAAavH,QAAU6H,KAIlB,kBAAMC,qBAAqBR,EAAStH,YAC1C,CAACqH,IFAJU,CACEC,uBACE,SAAClD,GACC,IAAImD,GAAgB,EAGpB3H,IAAQsG,GAAU,SAACsB,EAAO9B,GACpBa,EAASjH,QAAQoG,KACnB6B,GAAgB,EAChBC,EAAMpD,OAINmD,GAAiBpB,MAEvB,CAACI,EAAUL,EAAUC,KAIzBM,qBAAU,WACR,IAAMgB,EAAWC,OAAOC,KAAKzB,GAE7B,SAAS0B,EAAcC,GACjBJ,EAASK,SAASD,EAAMnC,MAC1BY,EAAS,CAAEN,KAAM,OAAQN,IAAKmC,EAAMnC,MAIxC,SAASqC,EAAYF,GACfJ,EAASK,SAASD,EAAMnC,MAC1BY,EAAS,CAAEN,KAAM,KAAMN,IAAKmC,EAAMnC,MAOtC,OAHAsC,SAASC,iBAAiB,UAAWL,GACrCI,SAASC,iBAAiB,QAASF,GAE5B,WACLC,SAASE,oBAAoB,UAAWN,GACxCI,SAASE,oBAAoB,QAASH,MAEvC,CAAC7B,EAAUI,IGpDhB,IAAM1C,EAAMlF,EAAY,IAClBe,EAAM,IAAIlC,EAAI,IACdyC,EAAS,IAAIsD,EAAO,IAAK,IAAK5E,EAAY,IAC1CmF,EAAa,IA0CnB,IAAMpC,EAAS,CACbC,UAAW,CACTyG,QAAS,S,MClDbC,IAASC,OAAOvJ,IAAMwJ,eDQP,WAAgB,IAAD,EACUC,oBAAS,GADnB,mBACrBC,EADqB,KACRC,EADQ,KAEtB/H,EEZO,SAAqBV,EAAQP,EAAKmE,EAAKC,GAAa,IAAD,EACxC0E,mBAAS,IAD+B,mBACzD7H,EADyD,KACnDgI,EADmD,KAG1D/E,EAAW2D,uBAAY,WAC3B,IAAMqB,EAAU3I,EAAO2D,SAASlE,EAAKmE,EAAKC,GAC1C6E,EAAQC,KACP,CAAC3I,EAAQP,EAAKmE,EAAKC,IAqBtB,OAnBA4C,qBAAU,WAAQ9C,MAAe,CAACA,IAElCsC,EACEX,mBACE,WACE,MAAO,CACLsD,EAAG,SAACxE,GAAcpE,EAAOsE,YAAY7E,EAAK2E,IAC1CyE,EAAG,SAACzE,GAAcpE,EAAOuE,aAAa9E,EAAK2E,IAC3C0E,EAAG,SAAC1E,GAAcpE,EAAOwE,SAAS/E,EAAK2E,IACvC2E,EAAG,SAAC3E,GAAcpE,EAAOyE,UAAUhF,EAAK2E,IACxC4E,UAAW,SAAC5E,GAAcpE,EAAOqE,SAASD,IAC1C6E,WAAY,SAAC7E,GAAcpE,EAAOmE,UAAUC,OAGhD,CAACpE,EAAQP,IAEX,CAAE0G,QAASxC,IAGNjD,EFfMwI,CAAYlJ,EAAQP,EAAKmE,EAAKC,GAE3C,OACE,yBAAKrC,MAAOC,EAAOC,WACjB,6BACE,kBAAC0D,EAAD,CACE5H,OAAQ,IACRoH,UAAWnF,EAAIjC,OACfwC,OAAQA,EACRU,KAAMA,EACNmD,WAAYA,EACZjC,MAAO,MAET,6BACE,oFACA,6BACE,2BAAOuH,QAAQ,gBAAf,eAEE,2BAAOC,GAAG,eAAeC,SAAU,kBAAMZ,GAAgBD,IAAcxC,KAAK,WAAWsD,QAASd,MAGpG,uBAAGe,KAAK,oCAAR,iBAGHf,GACC,kBAAC,EAAD,CACE5E,IAAKA,EACLnE,IAAKA,EACLO,OAAQA,EACRU,KAAMA,EACNmD,WAAYA,EACZpG,KAAM,UCzC0BuK,SAASwB,eAAe,W","file":"static/js/main.41d44904.chunk.js","sourcesContent":["export default function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\n// Return a new point with the values incremented by the passed-in values.\nPoint.prototype.add = function (x, y) {\n  return new Point(this.x + x, this.y + y);\n};\n\n// Return the distance between this point and another.\nPoint.prototype.distance = function (other) {\n  return Math.hypot(this.x - other.x, this.y - other.y);\n};\n","/* eslint-disable no-extend-native */\n\nimport Point from './point';\n\nexport default function Map(height) {\n  this.height = height;\n  this.size = 10;\n  this.grid = [\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],\n    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],\n    [1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 0, 1, 1, 1, 0, 1],\n    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  ];\n}\n\nMap.prototype.isWall = function (point) {\n  const gridCoordinates = toGrid(point, this.height);\n  return this.isWithinBounds(point) && this.grid[gridCoordinates.y][gridCoordinates.x] === 1;\n};\n\nMap.prototype.isWithinBounds = function (point) {\n  const gridCoordinates = toGrid(point, this.height);\n  return gridCoordinates.x >= 0 && gridCoordinates.x < this.size && gridCoordinates.y >= 0 && gridCoordinates.y < this.size;\n};\n\n// Convert unit coordinates to grid coordinates. Each grid coordinate can be broken up into\n// some number of smaller \"unit\" coordinates.\nfunction toGrid(point, unitsPerGrid) {\n  return new Point(Math.floor(point.x / unitsPerGrid), Math.floor(point.y / unitsPerGrid));\n}\n","export const twoPi = 2 * Math.PI;\n\n// Convert degrees to radians.\nexport function fromDegrees(degrees) {\n  return degrees * Math.PI / 180;\n}\n\n// Ensure that radians are between 0 and 2π.\nexport function normalize(radians) {\n  const newAngle = radians % twoPi;\n  return newAngle < 0 ? newAngle + twoPi : newAngle;\n}\n","import React from 'react';\nimport { twoPi } from '../utils/radians';\n\nexport default class Minimap extends React.Component {\n  wallsRef = React.createRef()\n  playerRef = React.createRef()\n  raysRef = React.createRef()\n\n  componentDidMount() {\n    this.drawWalls();\n    this.drawPlayer();\n    this.drawRays();\n  }\n\n  drawWalls() {\n    const context = this.wallsRef.current.getContext('2d');\n    const { map, size } = this.props;\n    const cellSize = size / map.size;\n\n    context.fillStyle = 'blue';\n\n    map.grid.forEach((row, y) => {\n      row.forEach((cell, x) => {\n        if (cell === 1) {\n          context.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n        }\n      });\n    });\n  }\n\n  drawPlayer() {\n    const context = this.playerRef.current.getContext('2d');\n    const { map, player, size } = this.props;\n    const { position } = player;\n    const gridX = position.x / map.height;\n    const gridY = position.y / map.height;\n    const cellSize = size / map.size;\n    const minimapX = gridX * cellSize;\n    const minimapY = gridY * cellSize;\n\n    context.clearRect(0, 0, size, size);\n    context.fillStyle = 'green';\n    context.beginPath();\n    context.arc(minimapX, minimapY, 5, 0, twoPi);\n    context.fill();\n  }\n\n  drawRays() {\n    const context = this.raysRef.current.getContext('2d');\n    const { map, rays, size } = this.props;\n    const cellSize = size / map.size;\n\n    context.clearRect(0, 0, size, size);\n    context.beginPath();\n    context.strokeStyle = 'green';\n\n    for (let i = 0; i < rays.length; i += 16) {\n      const { angle, distance, origin } = rays[i];\n      const gridX = origin.x / map.height;\n      const gridY = origin.y / map.height;\n      const gridDistance = distance / map.height;\n      const minimapX = gridX * cellSize;\n      const minimapY = gridY * cellSize;\n      const mapDistance = (size / map.size) * gridDistance;\n\n      context.moveTo(minimapX, minimapY);\n      context.lineTo(minimapX + mapDistance * Math.cos(angle), minimapY + mapDistance * -Math.sin(angle));\n      context.stroke();\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.rays !== this.props.rays) {\n      this.drawPlayer();\n      this.drawRays();\n    }\n  }\n\n  render() {\n    const { size } = this.props;\n    return (\n      <div style={styles.container}>\n        <canvas ref={this.wallsRef} height={size} width={size} style={styles.layer} />\n        <canvas ref={this.playerRef} height={size} width={size} style={styles.layer} />\n        <canvas ref={this.raysRef} height={size} width={size} style={styles.layer} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: 'relative',\n  },\n  layer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n  },\n};\n","import Point from './point';\nimport { normalize, twoPi } from './radians';\n\nexport default function Ray(map, angle, origin) {\n  this.origin = origin;\n  this.angle = normalize(angle);\n  this.distance = cast(map, this.angle, origin);\n}\n\n// Determine the distance travelled before hitting a wall.\nfunction cast(map, angle, origin) {\n  // Determine the direction the ray is travelling.\n  const up = angle > 0 && angle < Math.PI;\n  const right = angle < (twoPi * 0.25) || angle > (twoPi * 0.75);\n\n  // Determine the distance to the first horizontal wall.\n  const horizontalDistance = castHorizontal(map, origin, angle, up, right);\n\n  // Determine the distance to the first vertical wall.\n  const verticalDistance = castVertical(map, origin, angle, up, right);\n\n  // Return the shortest distance between the horizontal and vertical distances.\n  return Math.min(horizontalDistance, verticalDistance);\n}\n\n// Determine the distance travelled before hitting a _horizontal_ wall.\nfunction castHorizontal(map, origin, angle, up, right) {\n  // Calculate the coordinates of the first intersection with a grid boundary.\n  const intersectionY = Math.floor(origin.y / map.height) * map.height + (up ? -0.01 : map.height);\n  const intersectionX = origin.x + (origin.y - intersectionY) / Math.tan(angle);\n  const intersection = new Point(intersectionX, intersectionY);\n\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\n  const deltaY = up ? -map.height : map.height;\n  const deltaX = Math.abs(map.height / Math.tan(angle)) * (right ? 1 : -1);\n\n  // Find the nearest wall and return the distance to it.\n  const wall = findWall(map, intersection, deltaX, deltaY);\n  return wall.distance(origin);\n}\n\n// Determine the distance travelled before hitting a _vertical_ wall.\nfunction castVertical(map, origin, angle, up, right) {\n  // Calculate the coordinates of the first intersection with a grid boundary.\n  const intersectionX = Math.floor(origin.x / map.height) * map.height + (right ? map.height : -0.01);\n  const intersectionY = origin.y + (origin.x - intersectionX) * Math.tan(angle);\n  const intersection = new Point(intersectionX, intersectionY);\n\n  // Calculate the change in x and y coordinates needed to iterate across grid boundaries.\n  const deltaX = right ? map.height : -map.height;\n  const deltaY = Math.abs(map.height * Math.tan(angle)) * (up ? -1 : 1);\n\n  // Find the nearest wall and return the distance to it.\n  const wall = findWall(map, intersection, deltaX, deltaY);\n  return wall.distance(origin);\n}\n\n// Process each step the ray takes until encountering a wall or the bounds of the map.\nfunction findWall(map, position, deltaX, deltaY) {\n  // If the ray is no longer within the bounds of the map, return a point infinitely far away.\n  if (!map.isWithinBounds(position)) {\n    return new Point(Infinity, Infinity);\n  }\n\n  // If the ray has hit a wall, return its position.\n  if (map.isWall(position)) {\n    return position;\n  }\n\n  // No wall has been encountered. Iterate to the next grid boundary and check again.\n  return findWall(map, position.add(deltaX, deltaY), deltaX, deltaY);\n}\n","import Point from './point';\nimport Ray from './ray';\n\nconst stepDistance = 1.4; // per 16ms\nconst turnRotation = 0.025; // per 16ms\n\nexport default function Player(x, y, direction) {\n  this.position = new Point(x, y);\n  this.direction = direction;\n}\n\n// Determine the distance to walls the user can see by casting rays of light from the player's\n// eyes and figuring out where they intersect with a wall. The `resolution` is the number of rays\n// to cast, and `fov` determines how spread apart they will be.\nPlayer.prototype.castRays = function (map, fov, resolution) {\n  // If the field of view is 60 degrees and the resolution is 320, there is 60 / 320 degrees\n  // between each ray.\n  const angleBetweenRays = fov / resolution;\n\n  // The player's direction is the center of the screen, and the left edge of the screen is half\n  // the field of view to the left. In our coordinate system, angles increase as we turn counter-\n  // clockwise, so we add to player's current direction.\n  const startAngle = this.direction + fov / 2;\n\n  // Generate the angle for each ray starting from the left and sweeping to the right screen edge.\n  const rayAngles = new Array(resolution).fill(0).map((_, index) => startAngle - index * angleBetweenRays);\n\n  // Calculate the distance from each ray to the nearest wall.\n  return rayAngles.map(angle => new Ray(map, angle, this.position));\n};\n\nPlayer.prototype.turnRight = function (elapsed) {\n  this.direction -= turnRotation * elapsed / 16;\n};\n\nPlayer.prototype.turnLeft = function (elapsed) {\n  this.direction += turnRotation * elapsed / 16;\n};\n\nPlayer.prototype.moveForward = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(deltaX, 0), deltaX),\n    adjustDelta(map, this.position.add(0, -deltaY), -deltaY),\n  );\n};\n\nPlayer.prototype.moveBackward = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(-deltaX, 0), -deltaX),\n    adjustDelta(map, this.position.add(0, deltaY), deltaY),\n  );\n};\n\n// Step to the left, which is the same as stepping forward but rotated 90 degrees to the left.\nPlayer.prototype.moveLeft = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction + Math.PI / 2);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction + Math.PI / 2);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(deltaX, 0), deltaX),\n    adjustDelta(map, this.position.add(0, -deltaY), -deltaY),\n  );\n};\n\n// Step to the right, which is the same as stepping backward but rotated 90 degrees to the left.\nPlayer.prototype.moveRight = function (map, elapsed) {\n  const deltaX = stepDistance * (elapsed / 16) * Math.cos(this.direction + Math.PI / 2);\n  const deltaY = stepDistance * (elapsed / 16) * Math.sin(this.direction + Math.PI / 2);\n\n  this.position = this.position.add(\n    adjustDelta(map, this.position.add(-deltaX, 0), -deltaX),\n    adjustDelta(map, this.position.add(0, deltaY), deltaY),\n  );\n};\n\n// Perform collision-detection to determine if a proposed new position for the player is a valid\n// one. If it is, return the proposed delta. Otherwise, return 0.\nfunction adjustDelta(map, proposed, delta) {\n  return map.isWall(proposed) ? 0 : delta;\n}\n","import Color from 'color';\nimport React from 'react';\n\nexport default function Column({\n  color,\n  distance,\n  mapHeight,\n  number,\n  resolution,\n  screenHeight,\n  screenWidth,\n}) {\n  const height = Math.min(mapHeight / distance * 255, screenHeight);\n  const width = screenWidth / resolution;\n  const top = (screenHeight - height) / 2;\n  const adjustedColor = Color(color).darken(distance / 460).hex();\n  const styles = {\n    backgroundColor: adjustedColor,\n    height,\n    left: number * width,\n    width,\n    position: 'absolute',\n    top,\n  };\n\n  return <div style={styles} />;\n}\n","import React, { useMemo } from 'react';\nimport Column from './column';\n\nexport default function Scene({\n  height,\n  mapHeight,\n  player,\n  rays,\n  resolution,\n  width,\n}) {\n  const containerStyles = useMemo(() => ({ ...styles.container, height, width }), [height, width]);\n\n  return (\n    <div style={containerStyles}>\n      <div style={styles.ceiling} />\n      <div style={styles.floor} />\n      {rays.map((ray, index) => (\n        <Column\n          color=\"#0000FF\"\n          distance={adjustDistance(ray, player)}\n          key={index} // eslint-disable-line react/no-array-index-key\n          mapHeight={mapHeight}\n          number={index}\n          resolution={resolution}\n          screenHeight={height}\n          screenWidth={width}\n        />\n      ))}\n    </div>\n  );\n}\n\n// Correct for a fishbowl-effect resulting from mixing polar and cartesian coordinates.\nfunction adjustDistance(ray, player) {\n  return ray.distance * Math.cos(ray.angle - player.direction);\n}\n\nconst styles = {\n  container: {\n    border: '1px solid black',\n    position: 'relative',\n  },\n  ceiling: {\n    backgroundColor: 'SlateGrey',\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: '50%',\n    top: 0,\n  },\n  floor: {\n    backgroundColor: 'Gainsboro',\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: '50%',\n  },\n};\n","import forEach from 'lodash.foreach';\nimport { useCallback, useEffect } from 'react';\nimport useAnimationFrame from './useAnimationFrame';\nimport useImmutableStateReducer from './useImmutableStateReducer';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'down':\n      return { ...state, [action.key]: true };\n    case 'up':\n      return { ...state, [action.key]: false };\n    default:\n      return state;\n  }\n}\n\nexport default function useKeyPressing(handlers, { andThen = () => {} }) {\n  const [stateRef, dispatch] = useImmutableStateReducer(reducer, {});\n\n  useAnimationFrame(\n    useCallback(\n      (elapsed) => {\n        let isPressingKey = false;\n\n        // Execute the handler for all keys that are being pressed.\n        forEach(handlers, (value, key) => {\n          if (stateRef.current[key]) {\n            isPressingKey = true;\n            value(elapsed);\n          }\n        });\n\n        if (isPressingKey) { andThen(); }\n      },\n      [stateRef, handlers, andThen],\n    ),\n  );\n\n  useEffect(() => {\n    const keyNames = Object.keys(handlers);\n\n    function handleKeyDown(event) {\n      if (keyNames.includes(event.key)) {\n        dispatch({ type: 'down', key: event.key });\n      }\n    }\n\n    function handleKeyUp(event) {\n      if (keyNames.includes(event.key)) {\n        dispatch({ type: 'up', key: event.key });\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handlers, dispatch]);\n}\n","import { useEffect, useReducer, useRef } from 'react';\n\nexport default function useImmutableStateReducer(reducer, initialState) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const stateRef = useRef(state);\n\n  useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  return [stateRef, dispatch];\n}\n","import { useEffect, useRef } from 'react';\n\nexport default function useAnimationFrame(callback) {\n  const frameRef = useRef();\n  const timestampRef = useRef();\n\n  useEffect(() => {\n    timestampRef.current = window.performance.now();\n  }, []);\n\n  useEffect(() => {\n    function loop(timestamp) {\n      frameRef.current = requestAnimationFrame(loop);\n      callback(timestamp - timestampRef.current);\n      timestampRef.current = timestamp;\n    };\n\n    frameRef.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frameRef.current);\n  }, [callback]);\n};\n","import React, { useState } from 'react';\nimport Map from '../utils/map';\nimport Minimap from './minimap';\nimport Player from '../utils/player';\nimport Scene from './scene';\nimport useCastRays from '../hooks/useCastRays';\nimport { fromDegrees } from '../utils/radians';\n\nconst fov = fromDegrees(60);\nconst map = new Map(64);\nconst player = new Player(160, 160, fromDegrees(0));\nconst resolution = 320;\n\nexport default function App() {\n  const [showMinimap, setShowMinimap] = useState(true);\n  const rays = useCastRays(player, map, fov, resolution);\n\n  return (\n    <div style={styles.container}>\n      <div>\n        <Scene\n          height={400}\n          mapHeight={map.height}\n          player={player}\n          rays={rays}\n          resolution={resolution}\n          width={740}\n        />\n        <div>\n          <span>Move using the w, s, a, d, ←, and → keys</span>\n          <div>\n            <label htmlFor=\"show_minimap\">\n              Show minimap\n              <input id=\"show_minimap\" onChange={() => setShowMinimap(!showMinimap)} type=\"checkbox\" checked={showMinimap} />\n            </label>\n          </div>\n          <a href=\"https://github.com/ahuth/raycast\">Source code</a>\n        </div>\n      </div>\n      {showMinimap && (\n        <Minimap\n          fov={fov}\n          map={map}\n          player={player}\n          rays={rays}\n          resolution={resolution}\n          size={300}\n        />\n      )}\n    </div>\n  );\n}\n\nconst styles = {\n  container: {\n    display: 'flex',\n  },\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app';\nimport './index.css';\n\nReactDOM.render(React.createElement(App), document.getElementById('root'));\n","import { useCallback, useEffect, useMemo, useState } from 'react';\nimport useKeyPressing from './useKeyPressing';\n\nexport default function useCastRays(player, map, fov, resolution) {\n  const [rays, setRays] = useState([]);\n\n  const castRays = useCallback(() => {\n    const newRays = player.castRays(map, fov, resolution);\n    setRays(newRays);\n  }, [player, map, fov, resolution]);\n\n  useEffect(() => { castRays(); }, [castRays]);\n\n  useKeyPressing(\n    useMemo(\n      () => {\n        return {\n          w: (elapsed) => { player.moveForward(map, elapsed); },\n          s: (elapsed) => { player.moveBackward(map, elapsed); },\n          a: (elapsed) => { player.moveLeft(map, elapsed); },\n          d: (elapsed) => { player.moveRight(map, elapsed); },\n          ArrowLeft: (elapsed) => { player.turnLeft(elapsed); },\n          ArrowRight: (elapsed) => { player.turnRight(elapsed); },\n        };\n      },\n      [player, map],\n    ),\n    { andThen: castRays },\n  );\n\n  return rays;\n}\n"],"sourceRoot":""}